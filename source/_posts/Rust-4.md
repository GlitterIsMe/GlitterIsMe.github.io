---
title: Rust-4
date: 2018-06-20 20:38:30
tags: Rust
categories: Tech
---
# Glitter的Rust之旅（4）
## 所有权，好像很厉害
Rust是一门无需垃圾回收的即可保证内存安全的语言（GO语言就要），怎么做到呢，那当是通过所有权啦。所有权在Rust里的作用就是表明一个内存空间究竟属于哪个变量，并基于此制定Rust自己的规则，以及以此延伸出来的有关引用借用等概念。

<!-- more -->
## 什么是所有权？
Rust的所有权是围绕内存安全的问题来的，也就是和内存的分配有关，这也是教程里一来就用很大的篇幅介绍了栈分配（stack）以及堆分配（heap）的概念的原因。当然，熟悉C/C++的应该都对这两种内存分配方式很熟悉，简单来说就是栈分配是针对编译时就确定内存大小的数据，而堆分配是针对大小未定而运行时我们再给定我们所需要内存空间大小的数据，类似C/C++的malloc/new。位于栈上的变量，失效之后就会被移除栈自动释放空间，而位于堆上的变量，则需要我们尽可能去减少冗余数据以及清理不需要的数据，以至于不会就将堆空间消耗完，这也就是所有权需要解决的事。（这些都是我的理解）

## 所有权规则
下面内容划重点：
- Rust中每个值都有一个所有者（owner）变量
- 每个值有且仅有一个所有者
- 所有者离开作用域之后，值会被丢弃

以上三条关于所有权的规则，前面两条表明了每个值都一定对应唯一的所有者，而第三条则是跟作用域相关联。Rust的**作用域（scope）**和一般理解的作用域基本一致，而当一个变量进入作用域的时候开始生效，离开作用域之后立刻失效，并被自动回收。

## String类型
为了方便介绍所有权，教程这里介绍了String类型，也就是字符串类型。
之前也接触过字符串，比如
```
let a = "hello world";
```
这种字符串被称作字面值，被硬编码进程序，但是他们是不可变的（其实在C/C++也有这样的生命方式，而且关于他们为什么不可变还困扰了我很久）
但是不可能所有的字符串都能这样直接被声明，所以需要基于堆分配的字符串初始化方式，也就是这样：
```
let s = String::from("hello world");
```
这样声明就可以不用在编译的时候就知道字符串的长度，里面的helloworld还能是外部输入的字符串，而且如果把s声明为mut你还能修改它的值：
```
let mut s = String::from("hello");
s.push_str(", world");
```
（其实用法和C++里面的string也很像的只不过语法上有区别，关于结构体后面再讲

## 内存与分配
在声明一个String类型之后需要考虑两个问题：
- 什么时候分配内存
- 分配的内存什么时候收回去
第一个问题答案是在调用String::from的时候分配所需要的内存，而第二个问题是离开作用域的时候回收。String有个drop函数用于释放String的内存空间（似李！析构函数），在离开作用域的{}之后会自动调用drop函数，以释放占用的内存空间。

## 变量与数据交互的方式——移动
接下来教程介绍了关于所有权的一些应用场景，而且感觉也是Rust特有的一些场景，比如一个移动。
例子就是：
```
let x = 5;
let y = x;
let s1 = String::from("hello world");
let s2 = s1;
```
两组let看起来差不都但是本质上区别就很大，对于x/y这一组，由于是在栈上分配的，所以这里会获得两个变量，而且值都是5.如果你觉得你会获得两个hello world那就错了，这里就体现了Rust的特点。s1的声明的时候是这样：

![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-01.svg)
但是经过下一个赋值之后，这个绑定被转移到了s2身上，**同时s1不再有效**，比如这个时候你再访问s1，在编译阶段你的编译器就会把你给毙了，因为s1已经不再有效。这个操作即为**移动（move）**。这样做的理由就是如果s1仍具有所有权，那么在离开作用域的时候，s1的空间将会被释放两次，从而出现double free的情况，Rust这样的设计就完美的避开了这样的情况出现。

![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg)
其实这个概念就是C++里面常见到的深拷贝与浅拷贝的区别，前面`let s2 = s1`其实就是一个类似浅拷贝的过程。那如果我想进行深拷贝怎么办，Rust提供了一种方式叫做克隆。

## 变量与数据的交互方式——克隆
用法就是这样：
```
let s1 = String::from("hello");
let s2 = s1.clone();
```
这段代码里面访问s1就不会再出错，因为s2是指向另一段空间，并且复制了s1的内容。

![](https://kaisery.github.io/trpl-zh-cn/img/trpl04-03.svg)

## 所有权与函数
前面讲了赋值的情况，那么如果是函数的参数以及返回值又是怎样的情况呢，比如：
```
fn take_ownership(s:String){
    println!("s is {}", s);
}

fn makes_copy(i:i32){
    println!("i is {}", i);
}
fn main() {
    let s = String::from("hello world");
    take_ownership(s);
    println!("s is {}", s);//错误，这个s已经失效
    let x = 5;
    makes_copy(x);
}
```
在这个代码里面，main中的s在调用take_ownership之后，其所有权会被这个函数的参数给拿走，这时候主函数里面的s就失效了，所以这个程序在编译阶段就会报错：
![](https://ws1.sinaimg.cn/large/8c185877gy1fshx3zttq4j20lb075mx4.jpg)
并且告诉你你用了一个被move的变量

对于返回值，也可以转移作用域：
```
fn give_ownership() -> String{
    let s = String::from("hello");
    s
}

fn takes_and_giveback(s:String) -> String{
    s
}

fn main(){
    let s1 = give_ownership();
    let s2 = String::from("world");
    let s3 = takes_and_giveback(s2);
    println!("s1 is {}", s1);
    //println!("s2 is {}", s2);//s2失效，所有权转移到s3
    println!("s3 is {}", s3);
}
```
分析上面的程序就可以知道，通过give函数，s1获得了一个值的所有权所以在main里面我们能够打印它，而通过take_and_giveback函数，我们把s2的所有权拿走并通过返回值给了s3，所以在main里面s2就变得不能访问，而s3就可以正常访问

那么如果我们想要在一个函数里面访问一个值，是不是就必须先获取所有权再返还所有权呢？那岂不是就需要返回多个值（你一定要这么做可以通过元组来实现），不过还有更简便的方法，那就是引用，C++ programmer表示很亲切，但是也很胃疼，下次再说吧，我要鸽了。
![](https://ws1.sinaimg.cn/large/8c185877gy1fshxdy5fh6j202902c746.jpg)


