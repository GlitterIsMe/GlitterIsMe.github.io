---
title: Rust-3
date: 2018-06-15 16:45:18
tags: Rust
categories: Tech
---

# Glitter的Rust之旅（3）
## 函数与类型，熟悉与陌生

<!-- more -->
### Rust的函数
首先是函数的基本形式：
```
fn function( ){

}
```
乍一看和C/C++有点像，不过多了个关键字**fn**，Rust里面每个函数都会在最前面加上fn，来表示这是个函数。
那如果要给这个函数传入几个参数呢？形式也和我们认识的函数类似，在括号里面：
```
fn add(x: i32, y: i32){

}
```
emmm，除了参数都在括号里好像也没别的共同点了。这里需要注意的是，声明一个绑定的时候我们可以不声明一个变量的类型，但是函数的参数就不行，**必须声明每个参数的类型**，声明的方式和`let`类似，都是变量后面加上冒号加上数据类型。
然后我们如果我们需要函数返回计算结果，就需要声明返回值，Rust声明返回值的位置就不是像C/C++那样写在函数前面，而是像这样：
```
fn add(x: i32, y: i32) -> i32{
	x + y
}
```
也就是在参数的括号后面，函数体的{}前面，加上->并指明返回值类型
**注意了， 注意了，这里有个重要的坑点，敲黑板**
这个函数里面返回x+y但是x+y后面就没有分号，这个是错了吗？不这个才是对的，如果你加上分号：
![](https://ws1.sinaimg.cn/large/8c185877gy1fsbwd7afp1j20de082wef.jpg)
看到没，他说他想要一个i32返回值，但是你给了他一个()，what？这就涉及到一个Rust的重要特点：基于表达式
#### 表达式与语句
Rust是一门基于表达式的语言，他只有两种语句，而其他一切都是表达式，这里面主要的区别就在于**表达式返回一个值，但是语句没有**。Rust中语句只有两种：**声明语句**和**表达式语句**。
什么是声明语句？每个`let`绑定就是一个声明语句，其他语言里面可能支持这样的连等赋值
```
x = y = 5;
```
编译器会认为首先`y=5`是一个表达式，然后他的值是5，然后再赋值给x。但是Rust里面就不能这样，`let y = 5`不是一个表达式，这样`let x = (let y = 5)`就是错误的。
Rust里面对一个已经绑定过的变量进行赋值也是一个表达式，比如`y = 5`这就是一个表达式，但是他的返回值不是5，而是很奇怪的为`( )`，所以，如果你这样用：
```
let mut y = 1;
let x = (y = 5);
```
就把x给绑定了一个空的元组`()`
Rust的第二种语句是表达式语句，也就是把其他所有的表达式都变成语句，Rust希望语句后面是跟着语句，所以需要用分号来把表达式进行分割，分号则会出现在几乎每一行（教程里这么说），例外就是返回值的情况，如果返回值加上了分号，就会返回一个空的元组`()`.
#### 提早返回
如果我们在一个复杂的函数里面有多个返回点，仅通过表达式就不能实现在需要的地方进行返回了，那怎么办？
用`return`呗：
```
fn foo(x: i32) -> i32{
	return x;
    x + 1
}
```
return用法就跟我们熟悉的return一样，那么为什么我们不就使用return？！人家说这样是一种糟糕的风格，ok，you said the calculation。
![](https://ws1.sinaimg.cn/large/8c185877gy1fsbwuidgpaj20gd0b6wf4.jpg)
#### 发散函数
emmmm，Rust还定义了一种 发散函数，函数并不返回，形式像这样：
```
fn diverges() -> !{
	panic!("This fucntion never returns !")
}
```
发散函数就是返回值变成了`!`，这个函数运行到panic!()就会推出然后报告里面的信息，但是我也不知道发散函数有啥用？
![](https://ws1.sinaimg.cn/large/8c185877gy1fsbwye4jxlj20h704f0sm.jpg)

### 原生类型
这一部分就主要介绍Rust里面的各种数据类型，就像C/C++里面的char、int、数组之类的这种。
主要类型就先列个表格直观一点：

|类型|备注|
|-----|-----|
|bool|值为true或者false，常用于if|
|char|单独的Unicode字符，通过单引号`'`标识，如`'x'`，大小为**4byte**|
|数字类型|i为有符号，u为无符号，后面跟8、16、32、64表长度，也可以用isize/usize表可变大小，或者用f标识浮点类型|
|数组|下面详细讲|
|切片(Slice)|同上|
|元组(Tuple)|同上|

#### 数组
Rust的数组通过`[ ]`来声明，比如：
```
let a = [1, 2, 3];
let mut b = [1, 2, 3];
```
这里说，数组类型为[T; N]，这个跟后面的泛型有关系，那么就后面再说吧，T肯定就是类型，N就是数组大小，比如上面的a就是一个[i32, 3]的数组。
当然如果我们要声明一个大小为100的数组，不可能说我们把100个值都列出来，那么就是另一种声明方式：
```
let a2 = [20; 100];
```
这样就声明了一个长度为100的数组，还把全部值都初始化成了20，怎么跟python这么像？
对于一个数组a，可以用`a.len()`来获取数组长度，恩，这很OOP。
数据访问同样是[] + 下标，下标同样是从0开始，这一点都是很熟的。

#### 切片Slice
这个概念也很像python，实际是一个数组的引用，作用是能够安全地访问数组的一部分并且不用进行拷贝，Slice有预定义的长度，长度是可变的也可以是固定的。
切片的声明是这样的：
```
let a = [0, 1, 2, 3, 4, 5]//[i32; 6]的数组
let slice1 = &a[..];
let slice2 = &a[1..4];
```
这里声明了两个切片slice1和slice2，slice1表示包含了数组a的全部元组，而slice2表示包含a里面从a[1]到a[3]的元素，也就是说&a[x..y]是从a[x]到a[y-1]的元素

#### str
str是字符串类型，类型为&str，长度不定

#### 元组Tuple
元组是一个**固定大小的有序列表**，这个也和Python很像！比如：
```
let x = (1, "hello");
```
或者:
```
let x: (i32, &str) = (1, "hello")
```
元组可以直接赋值给另一个绑定，也可以有另一个奇妙的用法：**解构**let
大概像这样：
```
let (at, bt, ct) = ("str", 1, 'x');
```
这里就是通过let将一个绑定解开变成了三个绑定，很厉害啊
如果要访问元组，这里需要注意不是通过`[]`而是`.`，也就是：
```
let t = (1, 2, 3);
let t1 = t.0;
let t2 = t.1;
let t3 = t.2;
```
不过一样的是，索引也是从0开始（感觉像C++的pair？）

#### 函数
函数也是一个类型，比如：
```
fn add(x: i32, y:i32) -> i32{
	x+y
}
let x: fn(i32, i32)->i32 = add;
```
这里fn(i32, i32)->i32就是add函数的类型，恩和函数指针一样，就不多废话了

### 注释
最后再插一个小点，就是Rust的注释，这个和一般的静态语言基本一致（PY这种脚本语言一般用#就不说了），也是用`//`来表示行注释，而文档注释是通过`///`或者`//!`来实现。