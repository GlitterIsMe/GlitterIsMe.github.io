---
title: Rust-1
date: 2018-06-11 20:33:14
tags: Rust
categories: Tech
---
# Glitter的Rust之旅（1）
## 没错，我又要开一个新坑，你猜我能坚持多久？
因为一些机缘巧合（大概就是前一个项目还没着落，导师又刚好遇到另一家做开源存储系统的公司（大名鼎鼎的PingCAP），正好让我去了解一下这个公司的开源项目（大名鼎鼎的TiKV），然后了解到这是Rust写的。。。emmmm。。。所以为了能够更好地了解设计，我觉得还是学一下Rust比较好（听说Rust这门语言还不错），虽然后面不一定有项目而且也不一定能用的上，反正先学一点嘛，技多不压身（认真脸））
![](https://ws1.sinaimg.cn/large/8c185877gy1fs7ihlbpo3j2037039web.jpg)

<!-- more -->

## Rust安装
**我！还没搞定啊**（丢人！）
总之跟着官网的步骤走就应该没问题（我怎么就遇到问题了？）
首先打开官网下载exe
![](https://ws1.sinaimg.cn/large/8c185877gy1fs7hmko0yjj20nw0psju4.jpg)
*注意到下面的windows安装注意事项，这里踩了个坑，所以我现在正在下载VS2017*
装好之后的步骤下次再说吧，本来准备用Atom来写的，但是暂时先不管了，因为，我还没装好

## Rust语法语义
### Rust的变量绑定
对于每一门语言的教程，第一章一定是讲的变量，你的C/C++教科书第一章一定是从`int i = 5`（你说i=10那我也没办法）开始的。燃鹅，Rust的画风好像有点不一样（也有可能是我见识浅薄了，吃了文化的亏），Rust的第一章，叫**变量绑定**。
变量绑定的画风是这样的：
```
let x = 5;
```
而且注意到没，和`int i= 5`不一样的是，这里我们并没有告诉x，它的类型是啥，这在Rust中被叫做**类型推断**，也就是说他能自动识别x以及赋予其的值的类型，你就不需要明确地指出来了（对不起我第一次见这个，再次吃了文化的亏）。当然你要是实在想声明一个变量的类型，也可以做一个**类型注解（Type annotations）**，做法是：
```
let x: i32 = 5;
```
这里的i32表示x是一个有符号32位整数，i表示有符号（u表示无符号），32表示32位。
又来了一个不一样的地方就是，你通过`let`声明的x的值，是不可变的，what？这么不走寻常路？接着Rust介绍了怎么声明一个可变的变量：
```
let mut y = 10;
```
OK，这样y就可以被随心所欲地进行赋值了。这样的规则和我们所接触到的C/C++是完全相反的，C/C++里默认声明的变量是可变的，而对于常量你需要显式地声明`const`，而Rust，一个新的变量绑定是默认不可变的，你需要显式地声明`mut`才能成为一个可变的绑定，这样你可能会问，Why？我哪知道，他说安全。
![](https://ws1.sinaimg.cn/large/8c185877gy1fs7i3ptq9fj201r01smx6.jpg)
好的我们继续，对于默认的一个绑定，由于它是不可变的，所以我们就必须为其进行**初始化**，比如如果你声明了
```
let x;
```
这个时候编译能通过，但是当你脑袋一抽，去访问x的值的时候，比如
```
let x;
println!("x = {}", x);
```
就出问题了，哦没问题，因为你并不能通过编译(这里的{}类似于C/C++的printf中的%d的作用)
还有一个问题就是作用域的问题，和其它编程语言一样，Rust也有作用域的概念，也就是**变量都对应了一个作用域，变量只能在其作用域内被访问**，具体表现为：
```
{
	let x = 5;
    {
    	let y = 10;
     }
}
```
这里，y就不能在主函数内部被访问，因为y只属于他所在的那个程序块（{}内部），这一点跟其他编程语言是一致的。
然后还有一个问题，以前并没有注意到过，那就是隐藏，具体表现为**同一作用域下后声明的绑定可以覆盖先声明的绑定**，也就是这样的情况：
```
let x = 5;
...
let mut x = 10;
```
这种情况Rust不会报重复定义的错，而是会将原来的x声明给覆盖，这造成的问题是，原来的x占用的空间仍然存在，而且你还访问不了（类似C++的没有释放内存的情况），所以还是需要注意避免这样的情况（不要let x写嗨了忘了前面用过x）

