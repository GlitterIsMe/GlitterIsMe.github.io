---
title: Rust-3.5
date: 2018-06-19 20:21:52
tags: Rust
categories: Tech
---
# Glitter的Rust之旅（3.5）
## 单独划出来是因为上一章有点长了
重新去Rust官网找教程，发现找到的教程好像跟之前我看的不太一样，然后仔细看了下发现我看的是1.0版本，现在已经更新2.0版本了，还好之前摸鱼了（跑
这一章介绍Rust的控制流，在2.0教程中与前面两章的内容一起归于通用编程概念里面，所以我才写个3.5章（摊手

<!-- more -->
## 条件
### if-else
if-else语句的用法的语法都跟C/C++差不多，不过这里的条件不需要加上括号，就像这样：
```
fn main() {
    let num = 3;
    if num < 5{
        println!("{} < 5", num);
    }else{
        println!("{} >= 5", num);
    }
}
```
但是需要注意的是，**Rust并不会隐式地进行类型转换**，意思就是，if后面一定要是一个bool类型的值而不能是其他类型，如果是其他类型就会报错，这与其他语言会自动地进行转化是不一样的。
```
let num = 3;
if num {
	//错误，num不是一个bool类型的值
}
```

### let-if
这里Rust的let又开始显示出他很厉害的功能了，也就是let语句中使用if，总的来说就是根据if判断来进行let的绑定，听起来跟C/C++中的`? :`很像来着，用法是这样：
```
fn main() {
    let x = 1;
    let y = 2;
    let z = if x < y{
        -1//这里没分号
    }else{
        1
    };//这里有分号
    println!("z = {}", z);
}
```
有三点需要注意的，一是if后大括号内表达式不要有分号，至于为什么请看前一章；二是if语句块**最后一定要有分号**，也就是let语句的分号，这个不能忘了，不然就错了啊；三是if与else语句块**返回的类型一定要一样**，这样做是为了能在编译的时候就确定z的类型，下面这样就会出错：
```
 let z = if x < y{
        -1
    }else{
        "error"
    };
```

## 循环
循环也不陌生，不过Rust提供了三种循环，loop、while和for，while和for都很熟悉，那么什么是loop呢，我之前也没见过呢~

### loop
当你使用`loop`的时候就是告诉编译器，这段代码你给我一直跑，直到你要求它停下来为止，怎么用呢，这样的：
```
fn main() {
    loop{
        println!("hahahahhahaha" );
    }
}
```
简单的loop关键字加上后面你需要的循环的代码块就构成了loop语句，上面的代码运行之后你就可以让你的终端笑死
![](https://ws1.sinaimg.cn/large/8c185877gy1fsgqca0jn0j20b507aq2p.jpg)
![](https://ws1.sinaimg.cn/large/8c185877gy1fsgqbqfbq5j201y023dfx.jpg)
那怎么停下来呢，break啊（~~不要停下来啊~~

### while
while用法和平时认识的基本一样，就不细说了，同样condition不要加括号（while true不就是一个loop吗

### for
for语法和我们最开始接触的C中的for不太一样，更接近于现在的一些脚本语言（python）或者先进的面向对象的语言（C++11），给人一种用于迭代的感觉。怎么用呢？例如我们要遍历一个数组中的所有元素，如果用while来做：
```
fn main() {
    let x = [1,2,3,4,5];
    let mut i = 0;
    while i < 5{
        println!(" x[{}] = {}",i, x[i]);
        i = i + 1;
    }
}
```
这样写当然是可以~~但开发者想打断你的腿~~，但是执行的之后需要严格保证i不超过数组边界，一旦超过就会使得程序panic，但是如果我们不小心删掉了一个元素，又忘了改i值，那就GG了。并且运行时每次循环都要进行越界检查，拖慢了程序的运行速度，这个时候就该用for了：
```
fn main() {
    let x = [1,2,3,4,5];
    for num in x.iter(){
        println!("{}", num);
    }
}
```
所以大致的语法就是：`for var in ...`，var指代后面集合内的元素，通过这样的形式就能完美避免需要自己判断越界的情况，增强安全性。
如果需要循环计时，还可以用到`range`（和python很像），比如：
```
fn main() {
    let x = [1,2,3,4,5];
    for i in (1..10).rev(){
        println!("i = {}", i);
    }
}
```